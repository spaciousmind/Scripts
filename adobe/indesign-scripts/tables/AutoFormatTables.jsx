//DESCRIPTION:Auto-format simple tables [Jongware, 8-Apr-2013]if (parseFloat(app.version) < 6)	autoformattable ();else	app.doScript (autoformattable, ScriptLanguage.JAVASCRIPT,[true],UndoModes.ENTIRE_SCRIPT, "Autoformat Table [JW]");function autoformattable (){	if (app.documents.length == 0 || app.selection.length != 1)	{		alert ("Please place the cursor inside a table before running this script");		return;	}	aTable = app.selection[0];	if (aTable.hasOwnProperty("baseline") || aTable.hasOwnProperty("tables"))	{		if (aTable.tables.length >= 1)		{			if (confirm ("Process all tables?") == true)			{				app.scriptPreferences.enableRedraw = false;				for (var tt=0; tt<aTable.tables.length; tt++)					formatATable (aTable.tables[tt]);				app.scriptPreferences.enableRedraw = true;			}			return;		} else		{			aTable = app.selection[0].parent;		}	}//	if (app.selection[0].parent instanceof Cell)//		app.selection[0].parent.select();	while (aTable instanceof Cell || aTable instanceof Row || aTable instanceof Column)		aTable = aTable.parent;	if (!(aTable instanceof Table))	{		alert ("No table selected in any recognizable way ...");		return;	}	try {		aTable.rows[-1].cells[0].insertionPoints[0].horizontalOffset;	} catch (e)	{		alert ("Please make sure the table is NOT overset in its frame");		exit();	}	app.scriptPreferences.enableRedraw = false;	formatATable (aTable);	app.scriptPreferences.enableRedraw = true;}function formatATable (aTable){	// This will save the *original* column widths	var original = new Array;	// This will contain the *max* widths == no line breaks	var optimal = new Array;	// This will contain the *average* widths of all lines per column	var lineAverages = new Array;	// This will contain the *min* widths == no overset text	var minimum = new Array;	// This will contain a flag for 'entirely blank' columns	var blankColumns;	var c,i;	var startAtSize = aTable.width;	// count blank columns	blankColumns = GatherBlankColumns (aTable);	for (c=0; c<aTable.columns.length; c++)	{		original[c] = aTable.columns[c].width;	//	minimum[c] = SmallestPossibleColumn (aTable.columns[c]);		i = OptimalColumn (aTable.columns[c]);		optimal[c] = i[0];		lineAverages[c] = i[1];	}	// last result is optimal	// did we come out at a size *smaller* than the original?	// if so, we are done!	if (aTable.width <= startAtSize)	{		// at this point there is some space remaining, so		// divide this remaining space among the columns		// Make sure to skip entirely blank columns		nColWithText = 0;		for (col=0; col<aTable.columns.length; col++)		{			if (blankColumns[col] == false)			{				nColWithText++;			}		}		free = (startAtSize - aTable.width)/nColWithText;		for (col=0; col<aTable.columns.length; col++)		{			if (blankColumns[col] == false)			{				aTable.columns[col].width += free;			}		}		return;	}	// okay, so apparently we were too wide.	// 1. subtract minimum spaces from optimal width	// 2. add up what's left after that	// 3. divide it fairly, proportionally to optimal widths	nColToAdjust = 0;	spaceLeftToDivide = startAtSize;	spaceToConsider = 0;	for (c=0; c<aTable.columns.length; c++)	{		minimum[c] = SmallestPossibleColumn (aTable.columns[c]);	//	if (lineAverages[c] < minimum[c])	//		lineAverages[c] = minimum[c];		lineAverages[c] = optimal[c];		spaceLeftToDivide -= minimum[c];		spaceToConsider += (lineAverages[c] - minimum[c]);	}	// at this point the table is as slim as possible	// does it still end up wider than the original?	if (aTable.width > startAtSize)	{		for (c=0; c<aTable.columns.length; c++)			aTable.columns[c].width = original[c];		alert ("No solution found for this table");		return;	}	for (c=0; c<aTable.columns.length; c++)	{		aTable.columns[c].width = minimum[c] + spaceLeftToDivide*((lineAverages[c]-minimum[c])/spaceToConsider);	}}/* Locate entirely blank columns -- there are a couple   of situations where we might want to use this */function GatherBlankColumns (table){	var columnIsBlank = new Array(table.columns.length);	var txt, col, c;	for (col=0; col<table.columns.length; col++)	{		columnIsBlank[col] = true;		txt = table.columns[col].cells.everyItem().texts[0].contents;		for (c=0; c<txt.length; c++)		{			if (txt[c].length > 0)			{				columnIsBlank[col] = false;				break;			}		}	}	return columnIsBlank;}/* Find the smallest possible width without any overflow */function SmallestPossibleColumn (column){	var originalWidth = column.width;	var c,o,w, par, factor;	// any column with text?	par = column.cells.everyItem().texts[0].contents;	for (c=0; c<par.length; c++)	{		if (par[c].length > 0)			break;	}	if (c == par.length)		return originalWidth;	// do we start with overflow?	o = column.cells.everyItem().overflows;	for (c=0; c<o.length; c++)	{		// yes; fix it right away		while (o[c])		{			column.width *= 1.5;			column.recompose();			o = column.cells.everyItem().overflows;		}	}	// now make it smaller until it's hurtin'	factor = 2;	do	{		w = column.width;		try {			column.width *= (factor-1)/factor;			column.recompose();			o = column.cells.everyItem().overflows;			for (c=0; c<o.length; c++)			{				if (o[c])				{					column.width = w;					factor <<= 1;					break;				}			}		} catch (e)		{			factor <<= 1;		}	} while (factor <= 1024);	return column.width;}/* Find the smallest possible width with as little line   breaks as possible */function OptimalColumn (column){	var originalWidth = column.width;	var c,o,w, lineCount, factor, avgWidth, nAvgWidths;	// any column with text?	par = column.cells.everyItem().texts[0].contents;	for (c=0; c<par.length; c++)	{		if (par[c].length > 0)			break;	}	if (c == par.length)		return [originalWidth, originalWidth];	// do we start with overflow?	o = column.cells.everyItem().overflows;	for (c=0; c<o.length; c++)	{		// yes; fix it right away		while (o[c])		{			column.width *= 1.5;			column.recompose();			o = column.cells.everyItem().overflows;		}	}	// make sure there are as little line breaks	// as possible.	// .. just set some ridiculous large width ..	try {		column.width *= 100;	} catch (_) {		column.width *= 10;	}	column.recompose();	// count the lines	lineCount = column.cells.everyItem().texts[0].lines.everyItem().getElements();	try {		lengthsL = column.cells.everyItem().texts.everyItem().lines.everyItem().insertionPoints[0].horizontalOffset;	} catch (e)	{		alert ("problem with column "+(column.index+1));		exit();	}	lengthsR = column.cells.everyItem().texts[0].lines.everyItem().insertionPoints[-1].horizontalOffset;	lengthsR2= column.cells.everyItem().texts[0].lines.everyItem().insertionPoints[-2].horizontalOffset;	c = column.cells.everyItem().texts[0].lines.everyItem().contents;	// find widest line	widest = 0;	avgWidth = 0;	nAvgWidths = 0;	for (c=0; c<lengthsL.length; c++)	{		if (lengthsR[c] == lengthsL[c])			v = lengthsR2[c] - lengthsL[c];		else			v = lengthsR[c] - lengthsL[c];		avgWidth += v;		nAvgWidths++;		if (v > widest)			widest = v;	}	column.width = column.cells[0].leftInset + widest + column.cells[0].rightInset;	avgWidth /= nAvgWidths;//	alert (lengths[0]);	// now make it smaller until we start to feel it	factor = 2;	do	{		w = column.width;		try {			column.width *= (factor-1)/factor;			column.recompose();			// test overflow			o = column.cells.everyItem().overflows;			for (c=0; c<o.length; c++)			{				if (o[c])				{					column.width = w;					factor <<= 1;					break;				}			}			if (c >= o.length)			{				if (column.cells.everyItem().texts[0].lines.everyItem().getElements() > lineCount)				{					column.width = w;					factor <<= 1;				}			}		} catch (e)		{			column.width = w;			column.recompose();			factor <<= 1;		}	} while (factor <= 256);	return [ column.width, avgWidth ];}